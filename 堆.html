<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>语义写意玛尼堆 v2.0 - 聚簇结构版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-weight: 300; font-size: 20px; letter-spacing: 3px; color: #ffccaa; }
        p { font-size: 12px; color: rgba(255, 255, 255, 0.4); margin-top: 5px; }
    </style>
    <!-- 引入 Three.js 核心库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 轨道控制器，用于鼠标旋转查看 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info">
        <h1>SEMANTIC PILE V2</h1>
        <p>Structure Restored: Luminous Stone Clusters</p>
    </div>

    <script>
        // 1. 场景初始化
        const scene = new THREE.Scene();
        // 添加雾气，制造景深感 (颜色, 密度)
        scene.fog = new THREE.FogExp2(0x050505, 0.035);

        // 相机设置
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 35); // 拉近一点视角

        // 渲染器设置
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 优化高清屏显示
        document.body.appendChild(renderer.domElement);

        // 控制器设置
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 开启阻尼，有惯性感觉更高级
        controls.autoRotate = true;    // 开启自动旋转
        controls.autoRotateSpeed = 0.5; // 旋转速度
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // 限制不能钻到地下

        // 2. 粒子系统核心逻辑：聚簇生成 (Cluster Generation)
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        // 核心配色方案
        const colorCore = new THREE.Color(0xffaa33); // 核心琥珀色 (暖)
        const colorRim = new THREE.Color(0xaaccff);  // 边缘月光色 (冷)

        // 辅助函数：在指定位置生成一个“光之石” (一簇粒子)
        // cx, cy, cz: 石头中心坐标
        // radius: 石头半径
        // particleCount: 构成这块石头的粒子数量
        function createStoneCluster(cx, cy, cz, radius, particleCount) {
            for (let i = 0; i < particleCount; i++) {
                // 在球体表面均匀分布粒子 (Fibonacci Sphere算法简化版)
                const phi = Math.acos(-1 + (2 * i) / particleCount);
                const theta = Math.sqrt(particleCount * Math.PI) * phi;
                
                // 加入随机扰动，让石头看起来不那么圆，更像不规则天然石块
                const rVar = radius * (0.8 + Math.random() * 0.4);
                
                // 球坐标转笛卡尔坐标
                const x = cx + rVar * Math.cos(theta) * Math.sin(phi);
                const y = cy + rVar * Math.sin(theta) * Math.sin(phi);
                const z = cz + rVar * Math.cos(phi);

                positions.push(x, y, z);

                // 颜色逻辑：石头中心偏暖，边缘偏冷，形成体积感
                const mixFactor = Math.random();
                const mixedColor = colorCore.clone().lerp(colorRim, mixFactor * mixFactor);
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);

                // 大小逻辑：随机大小
                sizes.push(Math.random() * 0.3 + 0.1);
            }
        }

        // --- 玛尼堆建模逻辑 (基于照片结构) ---

        // A. 底部基座墙 (Cylindrical Wall)
        // 模拟照片里那一圈整齐的石头墙
        const baseRadius = 10;
        const baseHeight = 3.5;
        const layers = 5; // 叠5层石头
        
        for (let l = 0; l < layers; l++) {
            const y = (l / layers) * baseHeight - 3; // 从y=-3开始堆
            const circumference = 2 * Math.PI * baseRadius;
            const stoneSize = 0.8;
            const stonesInLayer = Math.floor(circumference / (stoneSize * 1.8)); // 计算这一圈能放多少石头
            
            for (let s = 0; s < stonesInLayer; s++) {
                // 错缝堆叠算法：偶数层旋转一下角度
                const angle = (s / stonesInLayer) * Math.PI * 2 + (l % 2) * 0.1; 
                const r = baseRadius + (Math.random() - 0.5) * 0.5; // 轻微半径抖动，更自然
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                // 生成一簇粒子代表一块石头
                createStoneCluster(x, y, z, 0.5, 15);
            }
        }

        // B. 内部填充与顶部堆叠 (The Pile)
        // 使用圆锥体分布
        const pileHeight = 8;
        const pileBaseY = 0.5; // 从基座墙顶端开始
        
        // 模拟堆积算法：层层向上收缩
        for (let h = 0; h < pileHeight; h += 0.8) {
            const progress = h / pileHeight;
            const currentRadius = (baseRadius - 1) * (1 - progress); // 半径线性收缩
            const stonesInRing = Math.floor((2 * Math.PI * currentRadius) / 1.5);
            
            // 每一层里的石头
            for (let s = 0; s < stonesInRing; s++) {
                // 在圆环内随机分布
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * currentRadius; 
                
                // 增加一点高度噪音，模拟自然堆叠的不平整
                const y = pileBaseY + h + (Math.random() - 0.5) * 0.5;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                // 越往上石头越小
                const stoneRadius = 0.4 + Math.random() * 0.3 * (1 - progress);
                createStoneCluster(x, y, z, stoneRadius, 10);
            }
        }

        // C. 顶部的几块大石头 (The Crown)
        createStoneCluster(0, pileBaseY + pileHeight, 0, 0.8, 40); // 顶端主石
        createStoneCluster(0.5, pileBaseY + pileHeight - 0.5, 0.5, 0.6, 25); // 侧边石


        // 将数据绑定到几何体
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        
        // 3. 材质：使用自定义着色器实现“光晕”效果
        // 这是一个简单的 Canvas 动态贴图生成器
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');       // 中心纯白
        gradient.addColorStop(0.4, 'rgba(255,240,200,0.5)');   // 中间淡金
        gradient.addColorStop(1, 'rgba(0,0,0,0)');             // 边缘透明
        context.fillStyle = gradient;
        context.fillRect(0, 0, 32, 32);
        const texture = new THREE.CanvasTexture(canvas);

        const material = new THREE.PointsMaterial({
            size: 0.5,
            map: texture,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // 叠加混合模式（关键：让重叠的光变亮）
            depthWrite: false, // 关闭深度写入，实现透明叠加
            sizeAttenuation: true
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // 4. 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 更新控制器状态
            renderer.render(scene, camera);
        }

        // 窗口自适应：拖动窗口大小时自动调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>